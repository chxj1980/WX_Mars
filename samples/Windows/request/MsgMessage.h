// **********************************************************************
// This file was generated by a TARS parser!
// TARS version 1.0.1.
// **********************************************************************

#ifndef __MSGMESSAGE_H_
#define __MSGMESSAGE_H_

#include <map>
#include <string>
#include <vector>
#include "Tars.h"
using namespace std;


namespace MessageService
{
    enum DeviceType
    {
        DeviceTypeIos = 1,
        DeviceTypeAndroid = 2,
        DeviceTypePc = 3,
        DeviceTypeOther = 6,
    };
    inline string etos(const DeviceType & e)
    {
        switch(e)
        {
            case DeviceTypeIos: return "DeviceTypeIos";
            case DeviceTypeAndroid: return "DeviceTypeAndroid";
            case DeviceTypePc: return "DeviceTypePc";
            case DeviceTypeOther: return "DeviceTypeOther";
            default: return "";
        }
    }
    inline int stoe(const string & s, DeviceType & e)
    {
        if(s == "DeviceTypeIos")  { e=DeviceTypeIos; return 0;}
        if(s == "DeviceTypeAndroid")  { e=DeviceTypeAndroid; return 0;}
        if(s == "DeviceTypePc")  { e=DeviceTypePc; return 0;}
        if(s == "DeviceTypeOther")  { e=DeviceTypeOther; return 0;}

        return -1;
    }

    enum SendMode
    {
        SendModeP2P = 0,
        SendModeGroup = 1,
        SendModeP2PS = 4,
        SendModeOneOfGroup = 5,
        SendModeAppBroadcast = 7,
        SendModeSystemBroadcast = 8,
    };
    inline string etos(const SendMode & e)
    {
        switch(e)
        {
            case SendModeP2P: return "SendModeP2P";
            case SendModeGroup: return "SendModeGroup";
            case SendModeP2PS: return "SendModeP2PS";
            case SendModeOneOfGroup: return "SendModeOneOfGroup";
            case SendModeAppBroadcast: return "SendModeAppBroadcast";
            case SendModeSystemBroadcast: return "SendModeSystemBroadcast";
            default: return "";
        }
    }
    inline int stoe(const string & s, SendMode & e)
    {
        if(s == "SendModeP2P")  { e=SendModeP2P; return 0;}
        if(s == "SendModeGroup")  { e=SendModeGroup; return 0;}
        if(s == "SendModeP2PS")  { e=SendModeP2PS; return 0;}
        if(s == "SendModeOneOfGroup")  { e=SendModeOneOfGroup; return 0;}
        if(s == "SendModeAppBroadcast")  { e=SendModeAppBroadcast; return 0;}
        if(s == "SendModeSystemBroadcast")  { e=SendModeSystemBroadcast; return 0;}

        return -1;
    }

    enum SendOption
    {
        SendOptionOfflineSave = 1,
        SendOptionIosPush = 4,
    };
    inline string etos(const SendOption & e)
    {
        switch(e)
        {
            case SendOptionOfflineSave: return "SendOptionOfflineSave";
            case SendOptionIosPush: return "SendOptionIosPush";
            default: return "";
        }
    }
    inline int stoe(const string & s, SendOption & e)
    {
        if(s == "SendOptionOfflineSave")  { e=SendOptionOfflineSave; return 0;}
        if(s == "SendOptionIosPush")  { e=SendOptionIosPush; return 0;}

        return -1;
    }

    enum MessageType
    {
        MessageTypeText = 1,
        MessageTypeImage,
        MessageTypeAudio,
        MessageTypeVideo,
        MessageTypeFile,
        MessageTypeGeo,
        MessageTypeCustom,
        MessageTypeTip,
        MessageTypeCommand,
        MessageTypeOperate = 80,
        MessageTypeOther = 120,
    };
    inline string etos(const MessageType & e)
    {
        switch(e)
        {
            case MessageTypeText: return "MessageTypeText";
            case MessageTypeImage: return "MessageTypeImage";
            case MessageTypeAudio: return "MessageTypeAudio";
            case MessageTypeVideo: return "MessageTypeVideo";
            case MessageTypeFile: return "MessageTypeFile";
            case MessageTypeGeo: return "MessageTypeGeo";
            case MessageTypeCustom: return "MessageTypeCustom";
            case MessageTypeTip: return "MessageTypeTip";
            case MessageTypeCommand: return "MessageTypeCommand";
            case MessageTypeOperate: return "MessageTypeOperate";
            case MessageTypeOther: return "MessageTypeOther";
            default: return "";
        }
    }
    inline int stoe(const string & s, MessageType & e)
    {
        if(s == "MessageTypeText")  { e=MessageTypeText; return 0;}
        if(s == "MessageTypeImage")  { e=MessageTypeImage; return 0;}
        if(s == "MessageTypeAudio")  { e=MessageTypeAudio; return 0;}
        if(s == "MessageTypeVideo")  { e=MessageTypeVideo; return 0;}
        if(s == "MessageTypeFile")  { e=MessageTypeFile; return 0;}
        if(s == "MessageTypeGeo")  { e=MessageTypeGeo; return 0;}
        if(s == "MessageTypeCustom")  { e=MessageTypeCustom; return 0;}
        if(s == "MessageTypeTip")  { e=MessageTypeTip; return 0;}
        if(s == "MessageTypeCommand")  { e=MessageTypeCommand; return 0;}
        if(s == "MessageTypeOperate")  { e=MessageTypeOperate; return 0;}
        if(s == "MessageTypeOther")  { e=MessageTypeOther; return 0;}

        return -1;
    }

    enum MessageOp
    {
        MessageOpCancelMessage = 300,
    };
    inline string etos(const MessageOp & e)
    {
        switch(e)
        {
            case MessageOpCancelMessage: return "MessageOpCancelMessage";
            default: return "";
        }
    }
    inline int stoe(const string & s, MessageOp & e)
    {
        if(s == "MessageOpCancelMessage")  { e=MessageOpCancelMessage; return 0;}

        return -1;
    }

    struct Message : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "MessageService.Message";
        }
        static string MD5()
        {
            return "46468d9f62d6bc5dc8f23829a461a69a";
        }
        Message()
        :msgId(0),seqId(0),from(""),to(""),sendMode(0),type(0),priority(0),handleOption(0),pushInfo(""),timestamp(0),expireTime(0)
        {
        }
        void resetDefautlt()
        {
            msgId = 0;
            seqId = 0;
            from = "";
            to = "";
            sendMode = 0;
            type = 0;
            priority = 0;
            handleOption = 0;
            pushInfo = "";
            timestamp = 0;
            expireTime = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            if (msgId != 0)
            {
                _os.write(msgId, 0);
            }
            _os.write(seqId, 1);
            _os.write(from, 2);
            _os.write(to, 3);
            _os.write(sendMode, 4);
            _os.write(type, 5);
            if (priority != 0)
            {
                _os.write(priority, 6);
            }
            _os.write(handleOption, 7);
            if (pushInfo != "")
            {
                _os.write(pushInfo, 8);
            }
            _os.write(timestamp, 9);
            _os.write(expireTime, 10);
            _os.write(content, 11);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(msgId, 0, false);
            _is.read(seqId, 1, true);
            _is.read(from, 2, true);
            _is.read(to, 3, true);
            _is.read(sendMode, 4, true);
            _is.read(type, 5, true);
            _is.read(priority, 6, false);
            _is.read(handleOption, 7, true);
            _is.read(pushInfo, 8, false);
            _is.read(timestamp, 9, true);
            _is.read(expireTime, 10, true);
            _is.read(content, 11, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(msgId,"msgId");
            _ds.display(seqId,"seqId");
            _ds.display(from,"from");
            _ds.display(to,"to");
            _ds.display(sendMode,"sendMode");
            _ds.display(type,"type");
            _ds.display(priority,"priority");
            _ds.display(handleOption,"handleOption");
            _ds.display(pushInfo,"pushInfo");
            _ds.display(timestamp,"timestamp");
            _ds.display(expireTime,"expireTime");
            _ds.display(content,"content");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(msgId, true);
            _ds.displaySimple(seqId, true);
            _ds.displaySimple(from, true);
            _ds.displaySimple(to, true);
            _ds.displaySimple(sendMode, true);
            _ds.displaySimple(type, true);
            _ds.displaySimple(priority, true);
            _ds.displaySimple(handleOption, true);
            _ds.displaySimple(pushInfo, true);
            _ds.displaySimple(timestamp, true);
            _ds.displaySimple(expireTime, true);
            _ds.displaySimple(content, false);
            return _os;
        }
    public:
        tars::Int64 msgId;
        tars::Int64 seqId;
        std::string from;
        std::string to;
        tars::Short sendMode;
        tars::Short type;
        tars::Char priority;
        tars::Short handleOption;
        std::string pushInfo;
        tars::Int32 timestamp;
        tars::Int32 expireTime;
        vector<tars::Char> content;
    };
    inline bool operator==(const Message&l, const Message&r)
    {
        return l.msgId == r.msgId && l.seqId == r.seqId && l.from == r.from && l.to == r.to && l.sendMode == r.sendMode && l.type == r.type && l.priority == r.priority && l.handleOption == r.handleOption && l.pushInfo == r.pushInfo && l.timestamp == r.timestamp && l.expireTime == r.expireTime && l.content == r.content;
    }
    inline bool operator!=(const Message&l, const Message&r)
    {
        return !(l == r);
    }

    struct MessageSet : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "MessageService.MessageSet";
        }
        static string MD5()
        {
            return "f7488a117d597b3499d93cffb66dd1df";
        }
        MessageSet()
        :from(""),to(""),sendMode(0)
        {
        }
        void resetDefautlt()
        {
            from = "";
            to = "";
            sendMode = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(from, 0);
            _os.write(to, 1);
            _os.write(sendMode, 3);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(from, 0, true);
            _is.read(to, 1, true);
            _is.read(sendMode, 3, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(from,"from");
            _ds.display(to,"to");
            _ds.display(sendMode,"sendMode");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(from, true);
            _ds.displaySimple(to, true);
            _ds.displaySimple(sendMode, false);
            return _os;
        }
    public:
        std::string from;
        std::string to;
        tars::Short sendMode;
    };
    inline bool operator==(const MessageSet&l, const MessageSet&r)
    {
        return l.from == r.from && l.to == r.to && l.sendMode == r.sendMode;
    }
    inline bool operator!=(const MessageSet&l, const MessageSet&r)
    {
        return !(l == r);
    }

    struct OffMsgInfo : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "MessageService.OffMsgInfo";
        }
        static string MD5()
        {
            return "c25c6b3a7811bf0f3565dff92c484ebc";
        }
        OffMsgInfo()
        :lastSeqId(0),lastUserSeqId(0)
        {
        }
        void resetDefautlt()
        {
            lastSeqId = 0;
            lastUserSeqId = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(queue, 0);
            _os.write(lastSeqId, 1);
            _os.write(lastUserSeqId, 2);
            _os.write(messsages, 3);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(queue, 0, true);
            _is.read(lastSeqId, 1, true);
            _is.read(lastUserSeqId, 2, true);
            _is.read(messsages, 3, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(queue,"queue");
            _ds.display(lastSeqId,"lastSeqId");
            _ds.display(lastUserSeqId,"lastUserSeqId");
            _ds.display(messsages,"messsages");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(queue, true);
            _ds.displaySimple(lastSeqId, true);
            _ds.displaySimple(lastUserSeqId, true);
            _ds.displaySimple(messsages, false);
            return _os;
        }
    public:
        MessageService::MessageSet queue;
        tars::Int64 lastSeqId;
        tars::Int64 lastUserSeqId;
        vector<MessageService::Message> messsages;
    };
    inline bool operator==(const OffMsgInfo&l, const OffMsgInfo&r)
    {
        return l.queue == r.queue && l.lastSeqId == r.lastSeqId && l.lastUserSeqId == r.lastUserSeqId && l.messsages == r.messsages;
    }
    inline bool operator!=(const OffMsgInfo&l, const OffMsgInfo&r)
    {
        return !(l == r);
    }

    struct SeqResp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "MessageService.SeqResp";
        }
        static string MD5()
        {
            return "2c37f79edf8937398af5420da9fc36d7";
        }
        SeqResp()
        :msgId(0),code(0),info("")
        {
        }
        void resetDefautlt()
        {
            msgId = 0;
            code = 0;
            info = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(msgId, 0);
            _os.write(code, 1);
            if (info != "")
            {
                _os.write(info, 2);
            }
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(msgId, 0, true);
            _is.read(code, 1, true);
            _is.read(info, 2, false);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(msgId,"msgId");
            _ds.display(code,"code");
            _ds.display(info,"info");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(msgId, true);
            _ds.displaySimple(code, true);
            _ds.displaySimple(info, false);
            return _os;
        }
    public:
        tars::Int32 msgId;
        tars::Short code;
        std::string info;
    };
    inline bool operator==(const SeqResp&l, const SeqResp&r)
    {
        return l.msgId == r.msgId && l.code == r.code && l.info == r.info;
    }
    inline bool operator!=(const SeqResp&l, const SeqResp&r)
    {
        return !(l == r);
    }


}



#endif
