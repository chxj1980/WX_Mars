// **********************************************************************
// This file was generated by a TARS parser!
// TARS version 1.0.1.
// **********************************************************************

#ifndef __OFFLINESERVICE_H_
#define __OFFLINESERVICE_H_

#include <map>
#include <string>
#include <vector>
#include "tars/Tars.h"
using namespace std;
#include "tars/msg_tars.h"

namespace MessageService
{
	struct OffMsgDesc : public tars::TarsStructBase
	{
	public:
		static string className()
		{
			return "MessageService.OffMsgDesc";
		}
		static string MD5()
		{
			return "012f5e5f8de14e1e26d73d1560296a28";
		}
		OffMsgDesc()
			:startMsgId(0), count(0)
		{
		}
		void resetDefautlt()
		{
			startMsgId = 0;
			count = 0;
		}
		template<typename WriterT>
		void writeTo(tars::TarsOutputStream<WriterT>& _os) const
		{
			_os.write(queue, 0);
			_os.write(startMsgId, 1);
			_os.write(count, 2);
		}
		template<typename ReaderT>
		void readFrom(tars::TarsInputStream<ReaderT>& _is)
		{
			resetDefautlt();
			_is.read(queue, 0, true);
			_is.read(startMsgId, 1, true);
			_is.read(count, 2, true);
		}
		ostream& display(ostream& _os, int _level = 0) const
		{
			tars::TarsDisplayer _ds(_os, _level);
			_ds.display(queue, "queue");
			_ds.display(startMsgId, "startMsgId");
			_ds.display(count, "count");
			return _os;
		}
		ostream& displaySimple(ostream& _os, int _level = 0) const
		{
			tars::TarsDisplayer _ds(_os, _level);
			_ds.displaySimple(queue, true);
			_ds.displaySimple(startMsgId, true);
			_ds.displaySimple(count, false);
			return _os;
		}
	public:
		MessageService::MessageQueue queue;
		tars::Int64 startMsgId;
		tars::Int32 count;
	};
	inline bool operator==(const OffMsgDesc&l, const OffMsgDesc&r)
	{
		return l.queue == r.queue && l.startMsgId == r.startMsgId && l.count == r.count;
	}
	inline bool operator!=(const OffMsgDesc&l, const OffMsgDesc&r)
	{
		return !(l == r);
	}

	struct OffMsgInfo : public tars::TarsStructBase
	{
	public:
		static string className()
		{
			return "MessageService.OffMsgInfo";
		}
		static string MD5()
		{
			return "8ccd6d13ad8a63dfb96e2403220548a1";
		}
		OffMsgInfo()
			:lastMsgId(0), lastUserMsgId(0)
		{
		}
		void resetDefautlt()
		{
			lastMsgId = 0;
			lastUserMsgId = 0;
		}
		template<typename WriterT>
		void writeTo(tars::TarsOutputStream<WriterT>& _os) const
		{
			_os.write(queue, 0);
			_os.write(lastMsgId, 1);
			_os.write(lastUserMsgId, 2);
			_os.write(messsages, 3);
		}
		template<typename ReaderT>
		void readFrom(tars::TarsInputStream<ReaderT>& _is)
		{
			resetDefautlt();
			_is.read(queue, 0, true);
			_is.read(lastMsgId, 1, true);
			_is.read(lastUserMsgId, 2, true);
			_is.read(messsages, 3, true);
		}
		ostream& display(ostream& _os, int _level = 0) const
		{
			tars::TarsDisplayer _ds(_os, _level);
			_ds.display(queue, "queue");
			_ds.display(lastMsgId, "lastMsgId");
			_ds.display(lastUserMsgId, "lastUserMsgId");
			_ds.display(messsages, "messsages");
			return _os;
		}
		ostream& displaySimple(ostream& _os, int _level = 0) const
		{
			tars::TarsDisplayer _ds(_os, _level);
			_ds.displaySimple(queue, true);
			_ds.displaySimple(lastMsgId, true);
			_ds.displaySimple(lastUserMsgId, true);
			_ds.displaySimple(messsages, false);
			return _os;
		}
	public:
		MessageService::MessageQueue queue;
		tars::Int64 lastMsgId;
		tars::Int64 lastUserMsgId;
		vector<MessageService::Message> messsages;
	};
	inline bool operator==(const OffMsgInfo&l, const OffMsgInfo&r)
	{
		return l.queue == r.queue && l.lastMsgId == r.lastMsgId && l.lastUserMsgId == r.lastUserMsgId && l.messsages == r.messsages;
	}
	inline bool operator!=(const OffMsgInfo&l, const OffMsgInfo&r)
	{
		return !(l == r);
	}

	struct WithdrawMsgReq : public tars::TarsStructBase
	{
	public:
		static string className()
		{
			return "MessageService.WithdrawMsgReq";
		}
		static string MD5()
		{
			return "6f096bcaea242ddea70e31fb7a3a47ac";
		}
		WithdrawMsgReq()
			:msgId(0)
		{
		}
		void resetDefautlt()
		{
			msgId = 0;
		}
		template<typename WriterT>
		void writeTo(tars::TarsOutputStream<WriterT>& _os) const
		{
			_os.write(msgQueue, 0);
			_os.write(msgId, 1);
		}
		template<typename ReaderT>
		void readFrom(tars::TarsInputStream<ReaderT>& _is)
		{
			resetDefautlt();
			_is.read(msgQueue, 0, true);
			_is.read(msgId, 1, true);
		}
		ostream& display(ostream& _os, int _level = 0) const
		{
			tars::TarsDisplayer _ds(_os, _level);
			_ds.display(msgQueue, "msgQueue");
			_ds.display(msgId, "msgId");
			return _os;
		}
		ostream& displaySimple(ostream& _os, int _level = 0) const
		{
			tars::TarsDisplayer _ds(_os, _level);
			_ds.displaySimple(msgQueue, true);
			_ds.displaySimple(msgId, false);
			return _os;
		}
	public:
		MessageService::MessageQueue msgQueue;
		tars::Int32 msgId;
	};
	inline bool operator==(const WithdrawMsgReq&l, const WithdrawMsgReq&r)
	{
		return l.msgQueue == r.msgQueue && l.msgId == r.msgId;
	}
	inline bool operator!=(const WithdrawMsgReq&l, const WithdrawMsgReq&r)
	{
		return !(l == r);
	}

	struct OffMsgInfoNotice : public tars::TarsStructBase
	{
	public:
		static string className()
		{
			return "MessageService.OffMsgInfoNotice";
		}
		static string MD5()
		{
			return "5563dda7749fc6693f03d82947a2f686";
		}
		OffMsgInfoNotice()
		{
		}
		void resetDefautlt()
		{
		}
		template<typename WriterT>
		void writeTo(tars::TarsOutputStream<WriterT>& _os) const
		{
			_os.write(msgInfos, 0);
		}
		template<typename ReaderT>
		void readFrom(tars::TarsInputStream<ReaderT>& _is)
		{
			resetDefautlt();
			_is.read(msgInfos, 0, true);
		}
		ostream& display(ostream& _os, int _level = 0) const
		{
			tars::TarsDisplayer _ds(_os, _level);
			_ds.display(msgInfos, "msgInfos");
			return _os;
		}
		ostream& displaySimple(ostream& _os, int _level = 0) const
		{
			tars::TarsDisplayer _ds(_os, _level);
			_ds.displaySimple(msgInfos, false);
			return _os;
		}
	public:
		vector<MessageService::OffMsgInfo> msgInfos;
	};
	inline bool operator==(const OffMsgInfoNotice&l, const OffMsgInfoNotice&r)
	{
		return l.msgInfos == r.msgInfos;
	}
	inline bool operator!=(const OffMsgInfoNotice&l, const OffMsgInfoNotice&r)
	{
		return !(l == r);
	}

	struct OfflineMsgReq : public tars::TarsStructBase
	{
	public:
		static string className()
		{
			return "MessageService.OfflineMsgReq";
		}
		static string MD5()
		{
			return "958b2dbb307c752638c4145526c061cc";
		}
		OfflineMsgReq()
		{
		}
		void resetDefautlt()
		{
		}
		template<typename WriterT>
		void writeTo(tars::TarsOutputStream<WriterT>& _os) const
		{
			_os.write(reqs, 0);
		}
		template<typename ReaderT>
		void readFrom(tars::TarsInputStream<ReaderT>& _is)
		{
			resetDefautlt();
			_is.read(reqs, 0, true);
		}
		ostream& display(ostream& _os, int _level = 0) const
		{
			tars::TarsDisplayer _ds(_os, _level);
			_ds.display(reqs, "reqs");
			return _os;
		}
		ostream& displaySimple(ostream& _os, int _level = 0) const
		{
			tars::TarsDisplayer _ds(_os, _level);
			_ds.displaySimple(reqs, false);
			return _os;
		}
	public:
		vector<MessageService::OffMsgDesc> reqs;
	};
	inline bool operator==(const OfflineMsgReq&l, const OfflineMsgReq&r)
	{
		return l.reqs == r.reqs;
	}
	inline bool operator!=(const OfflineMsgReq&l, const OfflineMsgReq&r)
	{
		return !(l == r);
	}

	struct OfflineMsgResp : public tars::TarsStructBase
	{
	public:
		static string className()
		{
			return "MessageService.OfflineMsgResp";
		}
		static string MD5()
		{
			return "9477fa54a556046da33c7db5574eba6b";
		}
		OfflineMsgResp()
			:code(0), info("")
		{
		}
		void resetDefautlt()
		{
			code = 0;
			info = "";
		}
		template<typename WriterT>
		void writeTo(tars::TarsOutputStream<WriterT>& _os) const
		{
			_os.write(code, 0);
			if (info != "")
			{
				_os.write(info, 1);
			}
			_os.write(msgs, 2);
		}
		template<typename ReaderT>
		void readFrom(tars::TarsInputStream<ReaderT>& _is)
		{
			resetDefautlt();
			_is.read(code, 0, true);
			_is.read(info, 1, false);
			_is.read(msgs, 2, true);
		}
		ostream& display(ostream& _os, int _level = 0) const
		{
			tars::TarsDisplayer _ds(_os, _level);
			_ds.display(code, "code");
			_ds.display(info, "info");
			_ds.display(msgs, "msgs");
			return _os;
		}
		ostream& displaySimple(ostream& _os, int _level = 0) const
		{
			tars::TarsDisplayer _ds(_os, _level);
			_ds.displaySimple(code, true);
			_ds.displaySimple(info, true);
			_ds.displaySimple(msgs, false);
			return _os;
		}
	public:
		tars::Short code;
		std::string info;
		vector<MessageService::Message> msgs;
	};
	inline bool operator==(const OfflineMsgResp&l, const OfflineMsgResp&r)
	{
		return l.code == r.code && l.info == r.info && l.msgs == r.msgs;
	}
	inline bool operator!=(const OfflineMsgResp&l, const OfflineMsgResp&r)
	{
		return !(l == r);
	}

}



#endif
