// **********************************************************************
// This file was generated by a TARS parser!
// TARS version 1.0.1.
// **********************************************************************

#ifndef __OFFLINESERVICE_H_
#define __OFFLINESERVICE_H_

#include <map>
#include <string>
#include <vector>
#include "tars/Tars.h"
using namespace std;

#include "tars/msg_tars.h"

namespace MessageService
{
    struct OffMsgDesc : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "MessageService.OffMsgDesc";
        }
        static string MD5()
        {
            return "baf395bb7913545ddc1152c099ae23b9";
        }
        OffMsgDesc()
        :startSeqId(0),count(0)
        {
        }
        void resetDefautlt()
        {
            startSeqId = 0;
            count = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(queue, 0);
            _os.write(startSeqId, 1);
            _os.write(count, 2);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(queue, 0, true);
            _is.read(startSeqId, 1, true);
            _is.read(count, 2, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(queue,"queue");
            _ds.display(startSeqId,"startSeqId");
            _ds.display(count,"count");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(queue, true);
            _ds.displaySimple(startSeqId, true);
            _ds.displaySimple(count, false);
            return _os;
        }
    public:
        MessageService::MessageSet queue;
        tars::Int64 startSeqId;
        tars::Int32 count;
    };
    inline bool operator==(const OffMsgDesc&l, const OffMsgDesc&r)
    {
        return l.queue == r.queue && l.startSeqId == r.startSeqId && l.count == r.count;
    }
    inline bool operator!=(const OffMsgDesc&l, const OffMsgDesc&r)
    {
        return !(l == r);
    }

    struct OffMsgInfo : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "MessageService.OffMsgInfo";
        }
        static string MD5()
        {
            return "c25c6b3a7811bf0f3565dff92c484ebc";
        }
        OffMsgInfo()
        :lastSeqId(0),lastUserSeqId(0)
        {
        }
        void resetDefautlt()
        {
            lastSeqId = 0;
            lastUserSeqId = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(queue, 0);
            _os.write(lastSeqId, 1);
            _os.write(lastUserSeqId, 2);
            _os.write(messsages, 3);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(queue, 0, true);
            _is.read(lastSeqId, 1, true);
            _is.read(lastUserSeqId, 2, true);
            _is.read(messsages, 3, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(queue,"queue");
            _ds.display(lastSeqId,"lastSeqId");
            _ds.display(lastUserSeqId,"lastUserSeqId");
            _ds.display(messsages,"messsages");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(queue, true);
            _ds.displaySimple(lastSeqId, true);
            _ds.displaySimple(lastUserSeqId, true);
            _ds.displaySimple(messsages, false);
            return _os;
        }
    public:
        MessageService::MessageSet queue;
        tars::Int64 lastSeqId;
        tars::Int64 lastUserSeqId;
        vector<MessageService::Message> messsages;
    };
    inline bool operator==(const OffMsgInfo&l, const OffMsgInfo&r)
    {
        return l.queue == r.queue && l.lastSeqId == r.lastSeqId && l.lastUserSeqId == r.lastUserSeqId && l.messsages == r.messsages;
    }
    inline bool operator!=(const OffMsgInfo&l, const OffMsgInfo&r)
    {
        return !(l == r);
    }

    struct WithdrawMsgReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "MessageService.WithdrawMsgReq";
        }
        static string MD5()
        {
            return "40d4f1c5bf982d97e46cf00a1f60f105";
        }
        WithdrawMsgReq()
        :msgSeqId(0)
        {
        }
        void resetDefautlt()
        {
            msgSeqId = 0;
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(msgQueue, 0);
            _os.write(msgSeqId, 1);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(msgQueue, 0, true);
            _is.read(msgSeqId, 1, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(msgQueue,"msgQueue");
            _ds.display(msgSeqId,"msgSeqId");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(msgQueue, true);
            _ds.displaySimple(msgSeqId, false);
            return _os;
        }
    public:
        MessageService::MessageSet msgQueue;
        tars::Int32 msgSeqId;
    };
    inline bool operator==(const WithdrawMsgReq&l, const WithdrawMsgReq&r)
    {
        return l.msgQueue == r.msgQueue && l.msgSeqId == r.msgSeqId;
    }
    inline bool operator!=(const WithdrawMsgReq&l, const WithdrawMsgReq&r)
    {
        return !(l == r);
    }

    struct OffMsgInfoNotice : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "MessageService.OffMsgInfoNotice";
        }
        static string MD5()
        {
            return "5563dda7749fc6693f03d82947a2f686";
        }
        OffMsgInfoNotice()
        {
        }
        void resetDefautlt()
        {
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(msgInfos, 0);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(msgInfos, 0, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(msgInfos,"msgInfos");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(msgInfos, false);
            return _os;
        }
    public:
        vector<MessageService::OffMsgInfo> msgInfos;
    };
    inline bool operator==(const OffMsgInfoNotice&l, const OffMsgInfoNotice&r)
    {
        return l.msgInfos == r.msgInfos;
    }
    inline bool operator!=(const OffMsgInfoNotice&l, const OffMsgInfoNotice&r)
    {
        return !(l == r);
    }

    struct OfflineMsgReq : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "MessageService.OfflineMsgReq";
        }
        static string MD5()
        {
            return "958b2dbb307c752638c4145526c061cc";
        }
        OfflineMsgReq()
        {
        }
        void resetDefautlt()
        {
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(reqs, 0);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(reqs, 0, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(reqs,"reqs");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(reqs, false);
            return _os;
        }
    public:
        vector<MessageService::OffMsgDesc> reqs;
    };
    inline bool operator==(const OfflineMsgReq&l, const OfflineMsgReq&r)
    {
        return l.reqs == r.reqs;
    }
    inline bool operator!=(const OfflineMsgReq&l, const OfflineMsgReq&r)
    {
        return !(l == r);
    }

    struct OfflineMsgResp : public tars::TarsStructBase
    {
    public:
        static string className()
        {
            return "MessageService.OfflineMsgResp";
        }
        static string MD5()
        {
            return "9477fa54a556046da33c7db5574eba6b";
        }
        OfflineMsgResp()
        :code(0),info("")
        {
        }
        void resetDefautlt()
        {
            code = 0;
            info = "";
        }
        template<typename WriterT>
        void writeTo(tars::TarsOutputStream<WriterT>& _os) const
        {
            _os.write(code, 0);
            if (info != "")
            {
                _os.write(info, 1);
            }
            _os.write(msgs, 2);
        }
        template<typename ReaderT>
        void readFrom(tars::TarsInputStream<ReaderT>& _is)
        {
            resetDefautlt();
            _is.read(code, 0, true);
            _is.read(info, 1, false);
            _is.read(msgs, 2, true);
        }
        ostream& display(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.display(code,"code");
            _ds.display(info,"info");
            _ds.display(msgs,"msgs");
            return _os;
        }
        ostream& displaySimple(ostream& _os, int _level=0) const
        {
            tars::TarsDisplayer _ds(_os, _level);
            _ds.displaySimple(code, true);
            _ds.displaySimple(info, true);
            _ds.displaySimple(msgs, false);
            return _os;
        }
    public:
        tars::Short code;
        std::string info;
        vector<MessageService::Message> msgs;
    };
    inline bool operator==(const OfflineMsgResp&l, const OfflineMsgResp&r)
    {
        return l.code == r.code && l.info == r.info && l.msgs == r.msgs;
    }
    inline bool operator!=(const OfflineMsgResp&l, const OfflineMsgResp&r)
    {
        return !(l == r);
    }

}

#endif