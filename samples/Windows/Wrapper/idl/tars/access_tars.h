// **********************************************************************
// This file was generated by a TARS parser!
// TARS version 1.0.1.
// **********************************************************************

#ifndef __ACCESSSERVICE_H_
#define __ACCESSSERVICE_H_

#include <map>
#include <string>
#include <vector>
#include "tars/Tars.h"
using namespace std;
#include "tars/msg_tars.h"

namespace MessageService
{
	enum CONNECT_RESULT
	{
		CONNECT_RESULT_SUCCESS = 0,
		CONNECT_RESULT_ERROR_PROTOCOL = 81,
		CONNECT_RESULT_ERROR_INDICATE = 82,
		CONNECT_RESULT_SERVICE_UNAVAILABLE = 83,
		CONNECT_RESULT_ERROR_USERNAME_OR_PASSWORD = 84,
		CONNECT_RESULT_KICKOUT = 85,
		CONNECT_RESULT_OTHER = 86,
	};
	inline string etos(const CONNECT_RESULT & e)
	{
		switch (e)
		{
		case CONNECT_RESULT_SUCCESS: return "CONNECT_RESULT_SUCCESS";
		case CONNECT_RESULT_ERROR_PROTOCOL: return "CONNECT_RESULT_ERROR_PROTOCOL";
		case CONNECT_RESULT_ERROR_INDICATE: return "CONNECT_RESULT_ERROR_INDICATE";
		case CONNECT_RESULT_SERVICE_UNAVAILABLE: return "CONNECT_RESULT_SERVICE_UNAVAILABLE";
		case CONNECT_RESULT_ERROR_USERNAME_OR_PASSWORD: return "CONNECT_RESULT_ERROR_USERNAME_OR_PASSWORD";
		case CONNECT_RESULT_KICKOUT: return "CONNECT_RESULT_KICKOUT";
		case CONNECT_RESULT_OTHER: return "CONNECT_RESULT_OTHER";
		default: return "";
		}
	}
	inline int stoe(const string & s, CONNECT_RESULT & e)
	{
		if (s == "CONNECT_RESULT_SUCCESS") { e = CONNECT_RESULT_SUCCESS; return 0; }
		if (s == "CONNECT_RESULT_ERROR_PROTOCOL") { e = CONNECT_RESULT_ERROR_PROTOCOL; return 0; }
		if (s == "CONNECT_RESULT_ERROR_INDICATE") { e = CONNECT_RESULT_ERROR_INDICATE; return 0; }
		if (s == "CONNECT_RESULT_SERVICE_UNAVAILABLE") { e = CONNECT_RESULT_SERVICE_UNAVAILABLE; return 0; }
		if (s == "CONNECT_RESULT_ERROR_USERNAME_OR_PASSWORD") { e = CONNECT_RESULT_ERROR_USERNAME_OR_PASSWORD; return 0; }
		if (s == "CONNECT_RESULT_KICKOUT") { e = CONNECT_RESULT_KICKOUT; return 0; }
		if (s == "CONNECT_RESULT_OTHER") { e = CONNECT_RESULT_OTHER; return 0; }

		return -1;
	}

	enum KICKOUT_REASON
	{
		KICKOUT_REASON_REPEAT = 80,
		KICKOUT_REASON_TOKEN_TIMEOUT = 81,
		KICKOUT_REASON_CLIENT_UNNORMAL = 82,
		KICKOUT_REASON_OUTSIDE = 83,
	};
	inline string etos(const KICKOUT_REASON & e)
	{
		switch (e)
		{
		case KICKOUT_REASON_REPEAT: return "KICKOUT_REASON_REPEAT";
		case KICKOUT_REASON_TOKEN_TIMEOUT: return "KICKOUT_REASON_TOKEN_TIMEOUT";
		case KICKOUT_REASON_CLIENT_UNNORMAL: return "KICKOUT_REASON_CLIENT_UNNORMAL";
		case KICKOUT_REASON_OUTSIDE: return "KICKOUT_REASON_OUTSIDE";
		default: return "";
		}
	}
	inline int stoe(const string & s, KICKOUT_REASON & e)
	{
		if (s == "KICKOUT_REASON_REPEAT") { e = KICKOUT_REASON_REPEAT; return 0; }
		if (s == "KICKOUT_REASON_TOKEN_TIMEOUT") { e = KICKOUT_REASON_TOKEN_TIMEOUT; return 0; }
		if (s == "KICKOUT_REASON_CLIENT_UNNORMAL") { e = KICKOUT_REASON_CLIENT_UNNORMAL; return 0; }
		if (s == "KICKOUT_REASON_OUTSIDE") { e = KICKOUT_REASON_OUTSIDE; return 0; }

		return -1;
	}

	struct LoginReq : public tars::TarsStructBase
	{
	public:
		static string className()
		{
			return "MessageService.LoginReq";
		}
		static string MD5()
		{
			return "f608f7c81a12477dc352fbb6402712e3";
		}
		LoginReq()
			:appId(""), userId(""), userName(""), token(""), deviceType(0), deviceToken("")
		{
		}
		void resetDefautlt()
		{
			appId = "";
			userId = "";
			userName = "";
			token = "";
			deviceType = 0;
			deviceToken = "";
		}
		template<typename WriterT>
		void writeTo(tars::TarsOutputStream<WriterT>& _os) const
		{
			_os.write(appId, 0);
			_os.write(userId, 1);
			if (userName != "")
			{
				_os.write(userName, 2);
			}
			_os.write(token, 3);
			_os.write(deviceType, 4);
			_os.write(deviceToken, 5);
		}
		template<typename ReaderT>
		void readFrom(tars::TarsInputStream<ReaderT>& _is)
		{
			resetDefautlt();
			_is.read(appId, 0, true);
			_is.read(userId, 1, true);
			_is.read(userName, 2, false);
			_is.read(token, 3, true);
			_is.read(deviceType, 4, true);
			_is.read(deviceToken, 5, true);
		}
		ostream& display(ostream& _os, int _level = 0) const
		{
			tars::TarsDisplayer _ds(_os, _level);
			_ds.display(appId, "appId");
			_ds.display(userId, "userId");
			_ds.display(userName, "userName");
			_ds.display(token, "token");
			_ds.display(deviceType, "deviceType");
			_ds.display(deviceToken, "deviceToken");
			return _os;
		}
		ostream& displaySimple(ostream& _os, int _level = 0) const
		{
			tars::TarsDisplayer _ds(_os, _level);
			_ds.displaySimple(appId, true);
			_ds.displaySimple(userId, true);
			_ds.displaySimple(userName, true);
			_ds.displaySimple(token, true);
			_ds.displaySimple(deviceType, true);
			_ds.displaySimple(deviceToken, false);
			return _os;
		}
	public:
		std::string appId;
		std::string userId;
		std::string userName;
		std::string token;
		tars::Short deviceType;
		std::string deviceToken;
	};
	inline bool operator==(const LoginReq&l, const LoginReq&r)
	{
		return l.appId == r.appId && l.userId == r.userId && l.userName == r.userName && l.token == r.token && l.deviceType == r.deviceType && l.deviceToken == r.deviceToken;
	}
	inline bool operator!=(const LoginReq&l, const LoginReq&r)
	{
		return !(l == r);
	}

	struct LoginResp : public tars::TarsStructBase
	{
	public:
		static string className()
		{
			return "MessageService.LoginResp";
		}
		static string MD5()
		{
			return "f1833e406b1a8d8d08d96538c1f9ea2d";
		}
		LoginResp()
			:code(MessageService::CONNECT_RESULT_SUCCESS), info(""), server_timeout(20)
		{
		}
		void resetDefautlt()
		{
			info = "";
			server_timeout = 20;
		}
		template<typename WriterT>
		void writeTo(tars::TarsOutputStream<WriterT>& _os) const
		{
			_os.write((tars::Int32)code, 0);
			if (info != "")
			{
				_os.write(info, 1);
			}
			if (server_timeout != 20)
			{
				_os.write(server_timeout, 2);
			}
		}
		template<typename ReaderT>
		void readFrom(tars::TarsInputStream<ReaderT>& _is)
		{
			resetDefautlt();
			tars::Int32 eTemp0 = MessageService::CONNECT_RESULT_SUCCESS;
			_is.read(eTemp0, 0, true);
			code = (MessageService::CONNECT_RESULT)eTemp0;
			_is.read(info, 1, false);
			_is.read(server_timeout, 2, false);
		}
		ostream& display(ostream& _os, int _level = 0) const
		{
			tars::TarsDisplayer _ds(_os, _level);
			_ds.display((tars::Int32)code, "code");
			_ds.display(info, "info");
			_ds.display(server_timeout, "server_timeout");
			return _os;
		}
		ostream& displaySimple(ostream& _os, int _level = 0) const
		{
			tars::TarsDisplayer _ds(_os, _level);
			_ds.displaySimple((tars::Int32)code, true);
			_ds.displaySimple(info, true);
			_ds.displaySimple(server_timeout, false);
			return _os;
		}
	public:
		MessageService::CONNECT_RESULT code;
		std::string info;
		tars::Int32 server_timeout;
	};
	inline bool operator==(const LoginResp&l, const LoginResp&r)
	{
		return l.code == r.code && l.info == r.info && l.server_timeout == r.server_timeout;
	}
	inline bool operator!=(const LoginResp&l, const LoginResp&r)
	{
		return !(l == r);
	}

	struct Kickout : public tars::TarsStructBase
	{
	public:
		static string className()
		{
			return "MessageService.Kickout";
		}
		static string MD5()
		{
			return "13fdd0f71acc627ee08e3e9b60670244";
		}
		Kickout()
			:code(MessageService::KICKOUT_REASON_REPEAT)
		{
		}
		void resetDefautlt()
		{
		}
		template<typename WriterT>
		void writeTo(tars::TarsOutputStream<WriterT>& _os) const
		{
			_os.write((tars::Int32)code, 0);
		}
		template<typename ReaderT>
		void readFrom(tars::TarsInputStream<ReaderT>& _is)
		{
			resetDefautlt();
			tars::Int32 eTemp0 = MessageService::KICKOUT_REASON_REPEAT;
			_is.read(eTemp0, 0, true);
			code = (MessageService::KICKOUT_REASON)eTemp0;
		}
		ostream& display(ostream& _os, int _level = 0) const
		{
			tars::TarsDisplayer _ds(_os, _level);
			_ds.display((tars::Int32)code, "code");
			return _os;
		}
		ostream& displaySimple(ostream& _os, int _level = 0) const
		{
			tars::TarsDisplayer _ds(_os, _level);
			_ds.displaySimple((tars::Int32)code, false);
			return _os;
		}
	public:
		MessageService::KICKOUT_REASON code;
	};
	inline bool operator==(const Kickout&l, const Kickout&r)
	{
		return l.code == r.code;
	}
	inline bool operator!=(const Kickout&l, const Kickout&r)
	{
		return !(l == r);
	}

	struct MsgReceipt : public tars::TarsStructBase
	{
	public:
		static string className()
		{
			return "MessageService.MsgReceipt";
		}
		static string MD5()
		{
			return "012f5e5f8de14e1e26d73d1560296a28";
		}
		MsgReceipt()
			:msgId(0), receiptCount(0)
		{
		}
		void resetDefautlt()
		{
			msgId = 0;
			receiptCount = 0;
		}
		template<typename WriterT>
		void writeTo(tars::TarsOutputStream<WriterT>& _os) const
		{
			_os.write(queue, 0);
			_os.write(msgId, 1);
			if (receiptCount != 0)
			{
				_os.write(receiptCount, 2);
			}
		}
		template<typename ReaderT>
		void readFrom(tars::TarsInputStream<ReaderT>& _is)
		{
			resetDefautlt();
			_is.read(queue, 0, true);
			_is.read(msgId, 1, true);
			_is.read(receiptCount, 2, false);
		}
		ostream& display(ostream& _os, int _level = 0) const
		{
			tars::TarsDisplayer _ds(_os, _level);
			_ds.display(queue, "queue");
			_ds.display(msgId, "msgId");
			_ds.display(receiptCount, "receiptCount");
			return _os;
		}
		ostream& displaySimple(ostream& _os, int _level = 0) const
		{
			tars::TarsDisplayer _ds(_os, _level);
			_ds.displaySimple(queue, true);
			_ds.displaySimple(msgId, true);
			_ds.displaySimple(receiptCount, false);
			return _os;
		}
	public:
		MessageService::MessageQueue queue;
		tars::Int64 msgId;
		tars::Int32 receiptCount;
	};
	inline bool operator==(const MsgReceipt&l, const MsgReceipt&r)
	{
		return l.queue == r.queue && l.msgId == r.msgId && l.receiptCount == r.receiptCount;
	}
	inline bool operator!=(const MsgReceipt&l, const MsgReceipt&r)
	{
		return !(l == r);
	}

	struct PresenceReq : public tars::TarsStructBase
	{
	public:
		static string className()
		{
			return "MessageService.PresenceReq";
		}
		static string MD5()
		{
			return "2e45701425f70f0e5c722cbe2c3f508e";
		}
		PresenceReq()
			:userId("")
		{
		}
		void resetDefautlt()
		{
			userId = "";
		}
		template<typename WriterT>
		void writeTo(tars::TarsOutputStream<WriterT>& _os) const
		{
			_os.write(userId, 0);
		}
		template<typename ReaderT>
		void readFrom(tars::TarsInputStream<ReaderT>& _is)
		{
			resetDefautlt();
			_is.read(userId, 0, true);
		}
		ostream& display(ostream& _os, int _level = 0) const
		{
			tars::TarsDisplayer _ds(_os, _level);
			_ds.display(userId, "userId");
			return _os;
		}
		ostream& displaySimple(ostream& _os, int _level = 0) const
		{
			tars::TarsDisplayer _ds(_os, _level);
			_ds.displaySimple(userId, false);
			return _os;
		}
	public:
		std::string userId;
	};
	inline bool operator==(const PresenceReq&l, const PresenceReq&r)
	{
		return l.userId == r.userId;
	}
	inline bool operator!=(const PresenceReq&l, const PresenceReq&r)
	{
		return !(l == r);
	}

	struct MonitorResp : public tars::TarsStructBase
	{
	public:
		static string className()
		{
			return "MessageService.MonitorResp";
		}
		static string MD5()
		{
			return "8106794cf632e731bac2d2c7b3d02723";
		}
		MonitorResp()
			:broker_id(""), user_online(0), send_msgs(0), recv_msgs(0)
		{
		}
		void resetDefautlt()
		{
			broker_id = "";
			user_online = 0;
			send_msgs = 0;
			recv_msgs = 0;
		}
		template<typename WriterT>
		void writeTo(tars::TarsOutputStream<WriterT>& _os) const
		{
			if (broker_id != "")
			{
				_os.write(broker_id, 0);
			}
			if (user_online != 0)
			{
				_os.write(user_online, 1);
			}
			if (send_msgs != 0)
			{
				_os.write(send_msgs, 2);
			}
			if (recv_msgs != 0)
			{
				_os.write(recv_msgs, 3);
			}
		}
		template<typename ReaderT>
		void readFrom(tars::TarsInputStream<ReaderT>& _is)
		{
			resetDefautlt();
			_is.read(broker_id, 0, false);
			_is.read(user_online, 1, false);
			_is.read(send_msgs, 2, false);
			_is.read(recv_msgs, 3, false);
		}
		ostream& display(ostream& _os, int _level = 0) const
		{
			tars::TarsDisplayer _ds(_os, _level);
			_ds.display(broker_id, "broker_id");
			_ds.display(user_online, "user_online");
			_ds.display(send_msgs, "send_msgs");
			_ds.display(recv_msgs, "recv_msgs");
			return _os;
		}
		ostream& displaySimple(ostream& _os, int _level = 0) const
		{
			tars::TarsDisplayer _ds(_os, _level);
			_ds.displaySimple(broker_id, true);
			_ds.displaySimple(user_online, true);
			_ds.displaySimple(send_msgs, true);
			_ds.displaySimple(recv_msgs, false);
			return _os;
		}
	public:
		std::string broker_id;
		tars::Int32 user_online;
		tars::Int32 send_msgs;
		tars::Int32 recv_msgs;
	};
	inline bool operator==(const MonitorResp&l, const MonitorResp&r)
	{
		return l.broker_id == r.broker_id && l.user_online == r.user_online && l.send_msgs == r.send_msgs && l.recv_msgs == r.recv_msgs;
	}
	inline bool operator!=(const MonitorResp&l, const MonitorResp&r)
	{
		return !(l == r);
	}


}

#endif